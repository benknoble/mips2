# programming macros
.include "prog.mips"

# constant definitions (opcodes, funcs, etc.)
# macros for extracting register-numbers, etc.
.include "instr.mips"

# macros for accessing memory, PC, simulated registers
.include "mem.mips"

# # IO facilities, esp. as macros?
# .include "io.mips"

# # assembled programs in labeled .data blocks
# .include "<sample_mips>.hex"
.include "iter-fact-12.hex" # iterfact12
.include "rec-fact-12.hex" # recfact12
.include "iter-fib-47.hex" # iterfib47
.include "rec-fib-12.hex" # recfib12
.include "bubble-sort.hex" # bubblesort
# # â€¦

.data
mode: .word 0

.eqv K_0 1
.eqv K_1 2
.eqv K_2 3
.eqv K_3 4
.eqv K_4 5
.eqv K_5 6

.eqv K_SPC 1
.eqv K_K 2

# main program
.text
menu:
    # wait until key pressed
    menu_key_loop: jal get_key
                   beq $v0 $0 menu_key_loop
    case $v0 K_0 toggle_mode
    case $v0 K_1 run_iterfact12
    case $v0 K_2 run_recfact12
    case $v0 K_3 run_iterfib47
    case $v0 K_4 run_recfib12
    case $v0 K_5 run_bubblesort
    case key_default

    toggle_mode:
        lw $t0 mode
        not $t0 $t0
        sw $t0 mode
        j menu
    run_iterfact12:
        la $t0 iterfact12
        case_break key_end
    run_recfact12:
        la $t0 recfact12
        case_break key_end
    run_iterfib47:
        la $t0 iterfib47
        case_break key_end
    run_recfib12:
        la $t0 recfib12
        case_break key_end
    run_bubblesort:
        la $t0 bubblesort
        case_break key_end
    key_default:
        j error
    key_end:
        sw $t0 progbase
        jal interpreter
    j menu
    # for mars only
    j mars_end

interpreter:
    subi $sp $sp 4
    sw $ra 0($sp)
    reset_pc
    reset_mem
    interpreter_loop: # {{{
        l_instr $s0
        # halt when instruction is 0x00000000
        beq $s0 $0 halt

        opcode $s0 $s1
        case $s1 0 DO_R

        # peel out pieces
        # $t0 = sign_ext_imm
        # $t1 = zero_ext_imm
        # $t2 = rs number
        # $t3 = rt number
        # $t4 = rf(rs)
        # $t5 = rf(rt)
        # $t6,7,8 free
        # $t9 = pc+4
        sign_ext_imm $s0 $t0
        zero_ext_imm $s0 $t1
        rs $s0 $t2
        rt $s0 $t3
        l_reg $t2 $t4
        l_reg $t3 $t5
        # reload these (modified in l_reg)
        rs $s0 $t2
        rt $s0 $t3
        l_pc $t9
        addi $t9 $t9 4

        .macro go_bt
            bt $s0 $t6
            s_pc $t6
        .end_macro
        .macro no_bt
            s_pc $t9
        .end_macro

        case $s1 OP_LW DO_LW
        case $s1 OP_SW DO_SW
        case $s1 OP_ADDI DO_ADDI
        case $s1 OP_ADDIU DO_ADDIU
        case $s1 OP_SLTI DO_SLTI
        case $s1 OP_SLTIU DO_SLTIU
        case $s1 OP_ORI DO_ORI
        case $s1 OP_LUI DO_LUI
        case $s1 OP_ANDI DO_ANDI
        case $s1 OP_XORI DO_XORI
        case $s1 OP_BEQ DO_BEQ
        case $s1 OP_BNE DO_BNE
        case $s1 OP_J DO_J
        case $s1 OP_JAL DO_JAL
        case op_default

        DO_LW: # {{{
            # l_data sign_ext_imm rs $t6
            l_data $t0 $t2 $t6
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_SW: # {{{
            # s_data sign_ext_imm rs rf(rt)
            s_data $t0 $t2 $t5
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_ADDI: # {{{
            # add $t6 sign_ext_imm rf(rs)
            add $t6 $t0 $t4
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_ADDIU: # {{{
            # addu $t6 sign_ext_imm rf(rs)
            addu $t6 $t0 $t4
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_SLTI: # {{{
            # slt $t6 rf(rs) sign_ext_imm
            slt $t6 $t4 $t0
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_SLTIU: # {{{
            # sltu $t6 rf(rs) sign_ext_imm
            sltu $t6 $t4 $t0
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_ORI: # {{{
            # or $t6 zero_ext_imm rf(rs)
            or $t6 $t1 $t4
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_LUI: # {{{
            # sll $t6 zero_ext_imm 16
            sll $t6 $t1 16
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_ANDI: # {{{
            # and $t6 zero_ext_imm rf(rs)
            and $t6 $t1 $t4
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_XORI: # {{{
            # xor $t6 zero_ext_imm rf(rs)
            xor $t6 $t1 $t4
            # s_reg rt $t6
            s_reg $t3 $t6
            # s_pc pc+4
            s_pc $t9
            case_break op_end # }}}
        DO_BEQ: # {{{
            # if beq rf(rs) rf(rt) go_bt no_bt
            if beq $t4 $t5 go_bt no_bt
            case_break op_end # }}}
        DO_BNE: # {{{
            # if bne rf(rs) rf(rt) go_bt no_bt
            if bne $t4 $t5 go_bt no_bt
            case_break op_end # }}}
        DO_J: # {{{
            # pc+4-4
            subi $t6 $t9 4
            # j_addr $s0 pc $t7
            j_addr $s0 $t6 $t7
            # s_pc $t7
            s_pc $t7
            case_break op_end # }}}
        DO_JAL: # {{{
            li $t6 REG_RA
            # s_reg 31 pc+4
            s_reg $t6 $t9
            j DO_J # }}}

        DO_R: # {{{
            # peel out pieces
            # $t0 = rd number
            # $t1 = rf(rd)
            # $t2 = rs number
            # $t3 = rt number
            # $t4 = rf(rs)
            # $t5 = rf(rt)
            # $t6 = shamt
            # $t7,8 free
            # $t9 = pc+4
            rd $s0 $t0
            l_reg $t0 $t1
            # reload
            rd $s0 $t0
            rs $s0 $t2
            rt $s0 $t3
            l_reg $t2 $t4
            l_reg $t3 $t5
            # reload
            rs $s0 $t2
            rt $s0 $t3
            shamt $s0 $t6
            l_pc $t9
            addi $t9 $t9 4

            funct $s0 $s1
            case $s1 FUNC_ADD DO_ADD
            case $s1 FUNC_ADDU DO_ADDU
            case $s1 FUNC_SUB DO_SUB
            case $s1 FUNC_AND DO_AND
            case $s1 FUNC_OR DO_OR
            case $s1 FUNC_XOR DO_XOR
            case $s1 FUNC_NOR DO_NOR
            case $s1 FUNC_SLT DO_SLT
            case $s1 FUNC_SLTU DO_SLTU
            case $s1 FUNC_SLL DO_SLL
            case $s1 FUNC_SLLV DO_SLLV
            case $s1 FUNC_SRL DO_SRL
            case $s1 FUNC_SRLV DO_SRLV
            case $s1 FUNC_SRA DO_SRA
            case $s1 FUNC_SRAV DO_SRAV
            case $s1 FUNC_JR DO_JR
            case $s1 FUNC_JALR DO_JALR
            case r_default

            DO_ADD: # {{{
                # add $t7 rf(rs) rf(rt)
                add $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_ADDU: # {{{
                # addu $t7 rf(rs) rf(rt)
                addu $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SUB: # {{{
                # sub $t7 rf(rs) rf(rt)
                sub $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_AND: # {{{
                # and $t7 rf(rs) rf(rt)
                and $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_OR: # {{{
                # or $t7 rf(rs) rf(rt)
                or $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_XOR: # {{{
                # xor $t7 rf(rs) rf(rt)
                xor $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_NOR: # {{{
                # nor $t7 rf(rs) rf(rt)
                nor $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SLT: # {{{
                # slt $t7 rf(rs) rf(rt)
                slt $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SLTU: # {{{
                # sltu $t7 rf(rs) rf(rt)
                sltu $t7 $t4 $t5
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SLL: # {{{
                # sllv because we don't know the shamt ($t0)
                # sllv $t7 rf(rt) shamt
                sllv $t7 $t5 $t6
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SLLV: # {{{
                # sllv $t7 rf(rt) rf(rs)
                sllv $t7 $t5 $t4
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SRL: # {{{
                # srlv $t7 rf(rt) shamt
                srlv $t7 $t5 $t6
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SRLV: # {{{
                # srlv $t7 rf(rt) rf(rs)
                srlv $t7 $t5 $t4
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SRA: # {{{
                # srav $t7 rf(rt) shamt
                srav $t7 $t5 $t6
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_SRAV: # {{{
                # srav $t7 rf(rt) rf(rs)
                srav $t7 $t5 $t4
                # s_reg rd $t7
                s_reg $t0 $t7
                # s_pc pc+4
                s_pc $t9
                case_break r_end # }}}
            DO_JR: # {{{
                jt $s0 $t7
                s_pc $t7
                case_break r_end # }}}
            DO_JALR: # {{{
                # store PC + 4 in $ra
                li $t7 REG_RA
                # s_reg 31 pc+4
                s_reg $t7 $t9
                j DO_JR # }}}

            r_default:
                j error
            r_end:
            case_break op_end # }}}

        op_default:
            j error
        op_end:
            lw $t0 mode
            beq $t0 $0 interpreter_continue
            interpreter_key_loop:
                jal get_key2
                beq $v0 $0 interpreter_key_loop
                case $v0 K_SPC interpreter_continue
                case $v0 K_K halt
                case error # default
            interpreter_continue:
                j interpreter_loop # }}}

    halt:
        move $v0 $0
        lw $ra 0($sp)
        addi $sp $sp 4
        jr $ra

# .include "procs_board.mips"
.include "procs_mars.mips"

error:
    # 0x00000000, also my halt code, easy to distinguish
    sll $0 $0 0

mars_end:
